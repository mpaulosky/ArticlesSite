@page "/articles/edit/{Id}"

@using Web.Components.Features.Articles.ArticleDetails
@inject NavigationManager Navigation
@inject ILogger<Edit> Logger
@inject GetCategories.IGetCategoriesHandler GetCategoriesHandler
@inject GetArticle.IGetArticleHandler GetArticleHandler
@inject EditArticle.IEditArticleHandler EditArticleHandler
@inject IJSRuntime JSRuntime

@attribute [Authorize]

<PageHeadingComponent HeaderText="Edit Article" Level="1" />

@if (_isLoading)
{
  <LoadingComponent />
}
else if (_errorMessage is not null)
{
  <ErrorAlertComponent Title="Unable to load article">
    @_errorMessage
  </ErrorAlertComponent>
}
else if (_editModel != ArticleDto.Empty)
{
  <div class="container-card">
    <EditForm Model="_editModel" OnValidSubmit="HandleValidSubmit">
      <DataAnnotationsValidator />
      <ValidationSummary />

      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
        <div>
          <label for="titleEdit" class="edit-label">Title</label>
          <InputTextArea id="titleEdit" class="form-control input-textbox"
            @bind-Value="_editModel.Title" />
        </div>

        <div>
          <label for="introductionEdit"
            class="edit-label">Introduction</label>
          <InputTextArea id="introductionEdit" class="form-control input-textbox"
            @bind-Value="_editModel.Introduction" rows="2" />
        </div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
        <div>
          <label for="categoryEdit" class="edit-label">
            <i class="bi bi-folder me-1"></i> Category
          </label>
          <InputSelect id="categoryEdit" class="form-control input-textbox"
            @bind-Value="_selectedCategoryId" @onchange="OnCategoryChanged">
            <option value="">Select A Category</option>
            @if (_categories != null && _categories.Any())
            {
              foreach (var cat in _categories)
              {
                <option value="@cat.Id.ToString()">@cat.CategoryName</option>
              }
            }
          </InputSelect>
        </div>

        <div>
          <label class="edit-label">
            <i class="bi bi-person-circle me-1"></i> Author
            <i class="bi bi-lock-fill text-gray-500 ms-1" title="Not editable"></i>
          </label>
          <div
            class="bg-white dark:bg-gray-800 text-gray-900 dark:text-white border border-blue-500 rounded px-3 py-2 font-semibold">
            @_editModel.Author?.Name
          </div>
        </div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
        <div class="flex items-center">
          <InputCheckbox id="isPublishedEdit" class="form-check-input mr-2" @bind-Value="_editModel.IsPublished" />
          <label for="isPublishedEdit" class="edit-label">Published</label>
        </div>

        <div class="flex items-center">
          <InputCheckbox id="isArchivedEdit" class="form-check-input mr-2" @bind-Value="_editModel.IsArchived" />
          <label for="isArchivedEdit" class="edit-label">Archived</label>
        </div>
      </div>

      <div class="mb-6">
        <label class="edit-label">Content (Markdown)</label>
        <TextEditor @bind-Content="@_editModel.Content" AlignmentOptionsEnabled="true" />
      </div>

      <div class="mt-8 flex gap-3 justify-end">
        <button type="submit" class="btn-primary">
          <i class="bi bi-save"></i> Save Changes
        </button>
        <button type="button" class="btn-secondary" @onclick="@(() => Navigation.NavigateTo($"/articles/details/{Id}"))">
          <i class="bi bi-arrow-left"></i> Cancel
        </button>
      </div>
    </EditForm>

    @if (_isConcurrencyConflict && _latestArticle is not null)
    {
      <div class="mt-6 border border-yellow-300 bg-yellow-50 p-4 rounded" role="alert" aria-live="polite">
        <h4 class="font-bold text-yellow-800">Concurrency Conflict</h4>
        <p class="text-sm text-yellow-700">The article was modified by another user while you were editing. Choose an action:</p>

        <div class="mt-3 grid grid-cols-1 md:grid-cols-3 gap-2">
          <button class="btn-primary" @onclick="ReloadLatestAsync">Reload Latest</button>
          <button class="btn-warning" @onclick="ForceOverwriteAsync">Force Overwrite</button>
          <button class="btn-secondary" @onclick="CancelToDetails">Cancel</button>
        </div>

        <div class="mt-4">
          <h5 class="font-semibold">Latest on server:</h5>
          <div class="p-2 bg-white rounded border">@_latestArticle.Title</div>
          <h5 class="font-semibold mt-2">Your draft:</h5>
          <div class="p-2 bg-white rounded border">@_editModel.Title</div>

          @{
            // Compute changed fields between latest and draft for display
            var changedFields = new List<string>();
            if (_latestArticle is not null && _editModel is not null)
            {
              if (_latestArticle.Title != _editModel.Title) changedFields.Add("Title");
              if (_latestArticle.Introduction != _editModel.Introduction) changedFields.Add("Introduction");
              if (_latestArticle.Content != _editModel.Content) changedFields.Add("Content");
              if (_latestArticle.CoverImageUrl != _editModel.CoverImageUrl) changedFields.Add("CoverImageUrl");
              if (_latestArticle.IsPublished != _editModel.IsPublished) changedFields.Add("IsPublished");
              if (_latestArticle.IsArchived != _editModel.IsArchived) changedFields.Add("IsArchived");
            }

            if (changedFields.Any())
            {
          }
          }

          @if (changedFields.Any())
          {
            <div class="mt-3">
              <h6 class="font-semibold">Changed fields:</h6>
              <ul>
                @foreach (var f in changedFields)
                {
                  <li>@f</li>
                }
              </ul>
            </div>
          }

        </div>
      </div>
    }
  </div>
}

@code {

  [Parameter] public required string Id { get; set; } = string.Empty;

  private ObjectId RecordId { get; set; } = ObjectId.Empty;

  [CascadingParameter] private Task<AuthenticationState>? AuthenticationState { get; set; }

  private ArticleDto _editModel = ArticleDto.Empty;

  private bool _isLoading = true;

  private string? _errorMessage;

  private List<CategoryDto>? _categories;

  private string _selectedCategoryId = string.Empty;

  // Concurrency UI state
  private bool _isConcurrencyConflict = false;
  private ArticleDto? _latestArticle;

  protected override async Task OnInitializedAsync()
  {

    RecordId = ObjectId.Parse(Id);

    Logger?.LogInformation("Loading article for edit: {ArticleId}", RecordId);
    _isLoading = true;

    try
    {
      // Load categories for the category dropdown
      await LoadCategoriesAsync();

      var articleResult = await GetArticleHandler.HandleAsync(RecordId);

      if (articleResult is { Success: true, Value: not null })
      {
        _editModel = articleResult.Value;
        _editModel.CanEdit = await UserCanEditArticleAsync(_editModel);
        _selectedCategoryId = _editModel.Category?.Id.ToString() ?? string.Empty;
        _errorMessage = null;
      }
      else
      {
        _errorMessage = articleResult.Error ?? "Article not found.";
      }
    }
    catch (Exception ex)
    {
      _errorMessage = ex.Message;
      Logger?.LogError(ex, "Error loading article for edit: {ArticleId}", RecordId);
    }
    finally
    {
      _isLoading = false;
    }
  }

  /// <summary>
  /// Determines whether the current user can edit the specified article.
  /// User can edit when they are in the \`Admin\` role or when they are the article's author.
  /// </summary>
  private async Task<bool> UserCanEditArticleAsync(ArticleDto? a)
  {
    if (AuthenticationState is null)
    {
      return false;
    }

    var authState = await AuthenticationState;
    var user = authState.User;

    if (user.Identity?.IsAuthenticated != true)
    {
      return false;
    }

    try
    {
      if (user.IsInRole("Admin"))
      {
        return true;
      }

      // Prefer stable identifier claims (Auth0 uses "sub"). Fall back to NameIdentifier.
      var currentUserId = user.FindFirst("sub")?.Value
      ?? user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;

      var authorId = a?.Author?.UserId;

      if (!string.IsNullOrEmpty(currentUserId) && !string.IsNullOrEmpty(authorId))
      {
        return string.Equals(currentUserId, authorId, StringComparison.OrdinalIgnoreCase);
      }
    }
    catch (Exception ex)
    {
      Logger?.LogWarning(ex, "Error evaluating edit permission for article {ArticleId}", a?.Id);
    }

    return false;
  }

  private async Task HandleValidSubmit()
  {
    if (_editModel == ArticleDto.Empty)
    {
      _errorMessage = "Nothing to save.";
      Logger?.LogWarning("HandleValidSubmit: _editModel was null for {ArticleId}", RecordId);

      return;
    }

    try
    {
      // Ensure the selected category is applied to the edit model
      if (!string.IsNullOrWhiteSpace(_selectedCategoryId) && ObjectId.TryParse(_selectedCategoryId, out var selectedCatId))
      {
        var selectedCategory = _categories?.FirstOrDefault(c => c.Id == selectedCatId);

        if (selectedCategory != null)
        {
          _editModel.Category = new Category
          {
            Id = selectedCategory.Id,
            CategoryName = selectedCategory.CategoryName,
            IsArchived = selectedCategory.IsArchived
          };
        }
      }
      else
      {
        // Allow clearing the category
        _editModel.Category = null;
      }

      var result = await EditArticleHandler.HandleAsync(_editModel);

      if (result.Success)
      {
        Logger?.LogInformation("Article saved: {ArticleId}", RecordId);
        _isConcurrencyConflict = false;
        Navigation.NavigateTo($"/articles/details/{RecordId}");
      }
      else
      {
        // Detect optimistic concurrency conflict and surface UI to user
        if (result.Error is not null && result.Error.Contains("Concurrency conflict", StringComparison.OrdinalIgnoreCase))
        {
          _isConcurrencyConflict = true;

          // Load latest article to show to user
          var latest = await GetArticleHandler.HandleAsync(RecordId);
          if (latest is { Success: true, Value: not null })
          {
            _latestArticle = latest.Value;
          }

          _errorMessage = "A concurrency conflict occurred. Choose an action below.";
          Logger?.LogWarning("HandleValidSubmit: Concurrency conflict saving article {ArticleId}", RecordId);
        }
        else
        {
          _errorMessage = result.Error ?? "Failed to save article.";
          Logger?.LogWarning("Failed to save article {ArticleId}: {Error}", RecordId, _errorMessage);
        }
      }
    }
    catch (Exception ex)
    {
      _errorMessage = ex.Message;
      Logger?.LogError(ex, "Error saving article {ArticleId}", RecordId);
    }
  }

  private async Task ReloadLatestAsync()
  {
    if (RecordId == ObjectId.Empty) return;

    var latest = await GetArticleHandler.HandleAsync(RecordId);
    if (latest is { Success: true, Value: not null })
    {
      _editModel = latest.Value;
      _editModel.CanEdit = await UserCanEditArticleAsync(_editModel);
      _selectedCategoryId = _editModel.Category?.Id.ToString() ?? string.Empty;
      _isConcurrencyConflict = false;
      _errorMessage = null;
    }
    else
    {
      _errorMessage = latest.Error ?? "Failed to load latest article.";
    }
  }

  private async Task ForceOverwriteAsync()
  {
    if (_latestArticle is null)
    {
      _errorMessage = "No latest article available to base overwrite on.";
      return;
    }

    // Set our DTO version to the latest server version so Replace will match and allow overwrite
    _editModel.Version = _latestArticle.Version;

    var result = await EditArticleHandler.HandleAsync(_editModel);
    if (result.Success)
    {
      _isConcurrencyConflict = false;
      Navigation.NavigateTo($"/articles/details/{RecordId}");
    }
    else
    {
      _errorMessage = result.Error ?? "Failed to overwrite article.";
      // If it's still a concurrency conflict, refresh latest to present to user again
      if (result.Error is not null && result.Error.Contains("Concurrency conflict", StringComparison.OrdinalIgnoreCase))
      {
        var latest = await GetArticleHandler.HandleAsync(RecordId);
        if (latest is { Success: true, Value: not null })
        {
          _latestArticle = latest.Value;
        }
      }
    }
  }

  private void CancelToDetails()
  {
    Navigation.NavigateTo($"/articles/details/{RecordId}");
  }

  private async Task LoadCategoriesAsync()
  {
    // Load categories using handler and handle errors
    try
    {
      var catResult = await GetCategoriesHandler.HandleAsync();
      _categories = catResult is { Success: true, Value: not null } ? catResult.Value.ToList() : [];

      if (!catResult.Success)
      {
        _errorMessage = catResult.Error ?? "Failed to load categories.";
        Logger?.LogWarning("Failed to load categories: {Error}", _errorMessage);
      }
    }
    catch (Exception ex)
    {
      _categories = [];
      _errorMessage = ex.Message;
      Logger?.LogError(ex, "Error loading categories");
    }
  }

  private void OnCategoryChanged(ChangeEventArgs e)
  {
    var selectedId = e.Value?.ToString() ?? string.Empty;
    _selectedCategoryId = selectedId;

    if (_categories != null && ObjectId.TryParse(selectedId, out var objId) && _categories.Any())
    {
      var selectedCategory = _categories.FirstOrDefault(c => c.Id == objId);

      if (selectedCategory != null)
      {
        _editModel.Category = new Category
        {
          Id = selectedCategory.Id,
          CategoryName = selectedCategory.CategoryName,
          IsArchived = selectedCategory.IsArchived
        };
      }
    }
    else
    {
      _editModel.Category = null;
    }
  }

}
